#include <sys/mman.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>

#define OP_ALIGN 64
#define INTRO_SIZE 64
#define CODE_MAX_SIZE 128

uint8_t instruction_0[OP_ALIGN] = {0x48, 0x8B, 0x45, 0xD0, 0x48, 0x8D, 0x0D, 0x35, 0x00, 0x00, 0x00, 0x48, 0x89, 0x08, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x8B, 0x45, 0xF0, 0x83, 0x00, 0x01, 0x48, 0x31, 0xC0, 0xB0, 0x00, 0x48, 0x8B, 0x4D, 0xF8, 0xC7, 0x04, 0x81, 0x00, 0x00, 0x00, 0x00};
uint8_t instruction_1[OP_ALIGN] = {0x48, 0x8B, 0x45, 0xD0, 0x48, 0x8D, 0x0D, 0x35, 0x00, 0x00, 0x00, 0x48, 0x89, 0x08, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x8B, 0x45, 0xF0, 0x83, 0x40, 0x04, 0x01, 0x48, 0x31, 0xC0, 0xB0, 0x00, 0x48, 0x8B, 0x4D, 0xF8, 0x8B, 0x14, 0x81, 0xB0, 0x00, 0x89, 0x14, 0x81};
uint8_t instruction_2[OP_ALIGN] = {0x48, 0x8B, 0x45, 0xD0, 0x48, 0x8D, 0x0D, 0x35, 0x00, 0x00, 0x00, 0x48, 0x89, 0x08, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x8B, 0x45, 0xF0, 0x83, 0x40, 0x08, 0x01, 0x48, 0x31, 0xC0, 0x48, 0x8B, 0x4D, 0xF8, 0xB0, 0x00, 0x8B, 0x14, 0x81, 0x48, 0x8B, 0x75, 0xE0, 0x8B, 0x14, 0x16, 0xB0, 0x00, 0x89, 0x14, 0x81};
uint8_t instruction_3[OP_ALIGN] = {0x48, 0x8B, 0x45, 0xD0, 0x48, 0x8D, 0x0D, 0x35, 0x00, 0x00, 0x00, 0x48, 0x89, 0x08, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x8B, 0x45, 0xF0, 0x83, 0x40, 0x0C, 0x01, 0x48, 0x31, 0xC0, 0x48, 0x8B, 0x4D, 0xF8, 0xB0, 0x00, 0x8B, 0x14, 0x81, 0xB0, 0x00, 0x8B, 0x04, 0x81, 0x48, 0x8B, 0x4D, 0xE0, 0x89, 0x14, 0x01};
uint8_t instruction_4[OP_ALIGN] = {0x48, 0x8B, 0x45, 0xD0, 0x48, 0x8D, 0x0D, 0x35, 0x00, 0x00, 0x00, 0x48, 0x89, 0x08, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x8B, 0x45, 0xF0, 0x83, 0x40, 0x10, 0x01, 0x48, 0x31, 0xC0, 0x48, 0x8B, 0x75, 0xE8, 0x48, 0x8B, 0x4D, 0xF8, 0xB0, 0x00, 0x8B, 0x14, 0x81, 0xB0, 0x00, 0x39, 0x14, 0x81, 0x0F, 0x9F, 0x06, 0x0F, 0x9C, 0x46, 0x01, 0x0F, 0x94, 0x46, 0x02};
uint8_t instruction_5[OP_ALIGN] = {0x48, 0x8B, 0x45, 0xD0, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0x08, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x8B, 0x45, 0xF0, 0x83, 0x40, 0x14, 0x01, 0xE9, 0x00, 0x00, 0x00, 0x00};
uint8_t instruction_6[OP_ALIGN] = {0x48, 0x8B, 0x45, 0xD0, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0x08, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x8B, 0x45, 0xF0, 0x83, 0x40, 0x18, 0x01, 0x48, 0x31, 0xC0, 0x48, 0x8B, 0x4D, 0xE8, 0x80, 0x39, 0x01, 0x0F, 0x84, 0x00, 0x00, 0x00, 0x00};
uint8_t instruction_7[OP_ALIGN] = {0x48, 0x8B, 0x45, 0xD0, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0x08, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x8B, 0x45, 0xF0, 0x83, 0x40, 0x1C, 0x01, 0x48, 0x31, 0xC0, 0x48, 0x8B, 0x4D, 0xE8, 0x80, 0x79, 0x01, 0x01, 0x0F, 0x84, 0x00, 0x00, 0x00, 0x00};
uint8_t instruction_8[OP_ALIGN] = {0x48, 0x8B, 0x45, 0xD0, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0x08, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x8B, 0x45, 0xF0, 0x83, 0x40, 0x20, 0x01, 0x48, 0x31, 0xC0, 0x48, 0x8B, 0x4D, 0xE8, 0x80, 0x79, 0x02, 0x01, 0x0F, 0x84, 0x00, 0x00, 0x00, 0x00};
uint8_t instruction_9[OP_ALIGN] = {0x48, 0x8B, 0x45, 0xD0, 0x48, 0x8D, 0x0D, 0x35, 0x00, 0x00, 0x00, 0x48, 0x89, 0x08, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x8B, 0x45, 0xF0, 0x83, 0x40, 0x24, 0x01, 0x48, 0x31, 0xC0, 0x48, 0x8B, 0x4D, 0xF8, 0xB0, 0x00, 0x8B, 0x14, 0x81, 0xB0, 0x00, 0x01, 0x14, 0x81};
uint8_t instruction_a[OP_ALIGN] = {0x48, 0x8B, 0x45, 0xD0, 0x48, 0x8D, 0x0D, 0x35, 0x00, 0x00, 0x00, 0x48, 0x89, 0x08, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x8B, 0x45, 0xF0, 0x83, 0x40, 0x28, 0x01, 0x48, 0x31, 0xC0, 0x48, 0x8B, 0x4D, 0xF8, 0xB0, 0x00, 0x8B, 0x14, 0x81, 0xB0, 0x00, 0x29, 0x14, 0x81};
uint8_t instruction_b[OP_ALIGN] = {0x48, 0x8B, 0x45, 0xD0, 0x48, 0x8D, 0x0D, 0x35, 0x00, 0x00, 0x00, 0x48, 0x89, 0x08, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x8B, 0x45, 0xF0, 0x83, 0x40, 0x2c, 0x01, 0x48, 0x31, 0xC0, 0x48, 0x8B, 0x4D, 0xF8, 0xB0, 0x00, 0x8B, 0x14, 0x81, 0xB0, 0x00, 0x21, 0x14, 0x81};
uint8_t instruction_c[OP_ALIGN] = {0x48, 0x8B, 0x45, 0xD0, 0x48, 0x8D, 0x0D, 0x35, 0x00, 0x00, 0x00, 0x48, 0x89, 0x08, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x8B, 0x45, 0xF0, 0x83, 0x40, 0x30, 0x01, 0x48, 0x31, 0xC0, 0x48, 0x8B, 0x4D, 0xF8, 0xB0, 0x00, 0x8B, 0x14, 0x81, 0xB0, 0x00, 0x09, 0x14, 0x81};
uint8_t instruction_d[OP_ALIGN] = {0x48, 0x8B, 0x45, 0xD0, 0x48, 0x8D, 0x0D, 0x35, 0x00, 0x00, 0x00, 0x48, 0x89, 0x08, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x8B, 0x45, 0xF0, 0x83, 0x40, 0x34, 0x01, 0x48, 0x31, 0xC0, 0x48, 0x8B, 0x4D, 0xF8, 0xB0, 0x00, 0x8B, 0x14, 0x81, 0xB0, 0x00, 0x31, 0x14, 0x81};
uint8_t instruction_e[OP_ALIGN] = {0x48, 0x8B, 0x45, 0xD0, 0x48, 0x8D, 0x0D, 0x35, 0x00, 0x00, 0x00, 0x48, 0x89, 0x08, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x8B, 0x45, 0xF0, 0x83, 0x40, 0x38, 0x01, 0x48, 0x31, 0xC0, 0x48, 0x8B, 0x4D, 0xF8, 0xB0, 0x00, 0x8B, 0x14, 0x81, 0x81, 0x24, 0x81, 0x00, 0x00, 0x00, 0x80, 0xC1, 0xE2, 0x00, 0x09, 0x14, 0x81};
uint8_t instruction_f[OP_ALIGN] = {0x48, 0x8B, 0x45, 0xD0, 0x48, 0x8D, 0x0D, 0x35, 0x00, 0x00, 0x00, 0x48, 0x89, 0x08, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x8B, 0x45, 0xF0, 0x83, 0x40, 0x3C, 0x01, 0x48, 0x31, 0xC0, 0x48, 0x8B, 0x4D, 0xF8, 0xB0, 0x00, 0xC1, 0x3C, 0x81, 0x00};

uint8_t i_size[16] = {23, 25, 32, 32, 40, 13, 24, 25, 25, 25, 25, 25, 25, 25, 33, 21};

FILE *in, *out;
uint8_t* code;
uint32_t* registers;
uint32_t* counters;
uint8_t* flags;
uint32_t current;
uint64_t pqp_rip;
uint64_t abs_addr;
void* mem;

uint32_t code_size;
uint32_t page_size;

uint8_t* to_bytes(uint8_t* bytes, int64_t num, uint8_t size);
int64_t from_bytes(uint8_t* bytes, uint8_t size);
void mem_write(uint32_t index, uint8_t* bytes, uint8_t size);
void minecraft();
void process_init();
void process_finish();

int main(int argc, char **argv){
  in = fopen(argv[1], "r");
  out = fopen(argv[2], "w");
  process_init();
  
  while(fscanf(in, "%hhX", &code[code_size]) == 1){
		code_size++;
	}
  
  {
    uint8_t addr[8];
    to_bytes(addr, (uint64_t)(mem + INTRO_SIZE + code_size * OP_ALIGN / 4), 8);
    uint8_t jmp[] = {0x48, 0xB8, addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7], 0xFF, 0xE0};
    uint8_t ret[] = {0x48, 0x89, 0xEC, 0x5D, 0xC3};
    for(uint32_t i = 0; i < ((code_size * OP_ALIGN) >> 2); i += OP_ALIGN){
      mem_write(INTRO_SIZE + i, jmp, sizeof(jmp));
    }
    mem_write(INTRO_SIZE + ((code_size * OP_ALIGN) >> 2), ret, 5);
  }

  while(current < code_size){
    uint32_t mem_index = INTRO_SIZE + ((current * OP_ALIGN) >> 2);
    pqp_rip = (uint64_t)(mem + mem_index);
      minecraft();
  }
  current = 4 * (abs_addr - (uint64_t)mem - INTRO_SIZE) / OP_ALIGN;
  fprintf(out, "0x%.8X->EXIT\n", current);
  fprintf(out, "[00:%u", counters[0]);
  for(uint8_t i = 1; i < 16; i++){
    fprintf(out, ",%.2X:%u", i, counters[i]);  
  }
  fprintf(out, "]\n");

  fprintf(out, "[R0=0x%.8X", registers[0]);
  for(uint8_t i = 1; i < 16; i++){
    fprintf(out, "|R%u=0x%.8X", i, registers[i]);  
  }
  fprintf(out, "]\n");
  
  process_finish();
  fclose(out);
  fclose(in);
  return 0;
}

void minecraft(){
  uint8_t* op;
  uint8_t reg_id;
  uint8_t reg1_id;
  uint8_t reg2_id;
  uint8_t signal;
  uint8_t offset;
  void (*jit)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t) = (void(*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))mem;
  
  switch(code[current]){
    case 0x0:
      op = instruction_0;
      offset = OP_ALIGN - i_size[0x0];
      reg_id = code[current+1] >> 4;
      signal = code[current+3] >> 7 ? 0xff : 0x00;
      op[0x0b + offset] = reg_id;
      op[0x13 + offset] = code[current+2];
      op[0x14 + offset] = code[current+3];
      op[0x15 + offset] = signal;
      op[0x16 + offset] = signal;
      mem_write(INTRO_SIZE + ((current * OP_ALIGN) >> 2), op, OP_ALIGN);
      (*jit)((uint64_t)registers, (uint64_t)counters, (uint64_t)flags, (uint64_t)code, (uint64_t)(&pqp_rip), (uint64_t)(&abs_addr));
      fprintf(out, "0x%.8X->MOV_R%d=0x%.8X\n", current, reg_id, registers[reg_id]);
      current += 4;
      break;
    case 0x1:
      op = instruction_1;
      offset = OP_ALIGN - i_size[0x1];
      reg1_id = code[current+1] >> 4;
      reg2_id = code[current+1] & 0x0f;
      op[0x0c + offset] = reg2_id;
      op[0x15 + offset] = reg1_id;
      mem_write(INTRO_SIZE + ((current * OP_ALIGN) >> 2), op, OP_ALIGN);
      (*jit)((uint64_t)registers, (uint64_t)counters, (uint64_t)flags, (uint64_t)code, (uint64_t)(&pqp_rip), (uint64_t)(&abs_addr));
      fprintf(out, "0x%.8X->MOV_R%d=R%d=0x%.8X\n", current, reg1_id, reg2_id, registers[reg2_id]);
      current += 4;
      break;
    case 0x2:
      op = instruction_2;
      offset = OP_ALIGN - i_size[0x2];
      reg1_id = code[current+1] >> 4;
      reg2_id = code[current+1] & 0x0f;
      op[0x10 + offset] = reg2_id;
      op[0x1c + offset] = reg1_id;
      mem_write(INTRO_SIZE + ((current * OP_ALIGN) >> 2), op, OP_ALIGN);
      {
        uint8_t reg2_val = registers[reg2_id];
        fprintf(out, "0x%.8X->MOV_R%d=MEM[0x%.2X,0x%.2X,0x%.2X,0x%.2X]=[0x%.2X,0x%.2X,0x%.2X,0x%.2X]\n", current, reg1_id, reg2_val, reg2_val+1, reg2_val+2, reg2_val+3, code[reg2_val], code[reg2_val+1], code[reg2_val+2], code[reg2_val+3]);
      }
      (*jit)((uint64_t)registers, (uint64_t)counters, (uint64_t)flags, (uint64_t)code, (uint64_t)(&pqp_rip), (uint64_t)(&abs_addr));
      current += 4;
      break;
    case 0x3:
      op = instruction_3;
      offset = OP_ALIGN - i_size[0x3];
      reg1_id = code[current+1] >> 4;
      reg2_id = code[current+1] & 0x0f;
      op[0x10 + offset] = reg2_id;
      op[0x15 + offset] = reg1_id;
      mem_write(INTRO_SIZE + ((current * OP_ALIGN) >> 2), op, OP_ALIGN);
      {
        uint8_t reg1_val = registers[reg1_id];
        uint8_t bytes[4];
        to_bytes(bytes, registers[reg2_id], 4);
        fprintf(out, "0x%.8X->MOV_MEM[0x%.2X,0x%.2X,0x%.2X,0x%.2X]=R%d=[0x%.2X,0x%.2X,0x%.2X,0x%.2X]\n", current, reg1_val, reg1_val+1, reg1_val+2, reg1_val+3, reg2_id, bytes[0], bytes[1], bytes[2], bytes[3]);
      }
      (*jit)((uint64_t)registers, (uint64_t)counters, (uint64_t)flags, (uint64_t)code, (uint64_t)(&pqp_rip), (uint64_t)(&abs_addr));
      current += 4;
      break;
    case 0x4:
      op = instruction_4;
      offset = OP_ALIGN - i_size[0x4];
      reg1_id = code[current+1] >> 4;
      reg2_id = code[current+1] & 0x0f;
      op[0x14 + offset] = reg2_id;
      op[0x19 + offset] = reg1_id;
      mem_write(INTRO_SIZE + ((current * OP_ALIGN) >> 2), op, OP_ALIGN);
      (*jit)((uint64_t)registers, (uint64_t)counters, (uint64_t)flags, (uint64_t)code, (uint64_t)(&pqp_rip), (uint64_t)(&abs_addr));
      fprintf(out, "0x%.8X->CMP_R%d<=>R%d(G=%d,L=%d,E=%d)\n", current, reg1_id, reg2_id, flags[0], flags[1], flags[2]);
      current += 4;
      break;
    case 0x5:
      op = instruction_5;
      offset = OP_ALIGN - i_size[0x5];
      signal = code[current+3] >> 7 ? 0xff : 0x00;
      {
        uint8_t bytes[4] = {code[current+2], code[current+3], signal, signal};
        uint8_t abs_mem[8];
        int32_t n = from_bytes(bytes, 4);
        int32_t prop = n;
        int32_t next = current + 4 + n;
        if(next < 0 || next >= CODE_MAX_SIZE){
          n = (int32_t)(code_size - current - 4);
        }
        n *= OP_ALIGN / 4;
        to_bytes(bytes, n, 4);
        op[0x09 + offset] = bytes[0];
        op[0x0a + offset] = bytes[1];
        op[0x0b + offset] = bytes[2];
        op[0x0c + offset] = bytes[3];
        uint64_t abs = (uint64_t)mem + INTRO_SIZE + (((current + 4 + prop) * OP_ALIGN) >> 2);
        to_bytes(abs_mem, abs, 8);
        op[0x06] = abs_mem[0]; op[0x07] = abs_mem[1];
        op[0x08] = abs_mem[2]; op[0x09] = abs_mem[3];
        op[0x0a] = abs_mem[4]; op[0x0b] = abs_mem[5];
        op[0x0c] = abs_mem[6]; op[0x0d] = abs_mem[7];
        mem_write(INTRO_SIZE + ((current * OP_ALIGN) >> 2), op, OP_ALIGN);

        (*jit)((uint64_t)registers, (uint64_t)counters, (uint64_t)flags, (uint64_t)code, (uint64_t)(&pqp_rip), (uint64_t)(&abs_addr));
        fprintf(out, "0x%.8X->JMP_0x%.8X\n", current, current + 4 + prop);
        current += 4 + prop;
      }
      break;
    case 0x6:
      op = instruction_6;
      offset = OP_ALIGN - i_size[0x6];
      signal = code[current+3] >> 7 ? 0xff : 0x00;
      {
        uint8_t bytes[4] = {code[current+2], code[current+3], signal, signal};
        uint8_t abs_mem[8];
        int32_t n = from_bytes(bytes, 4);
        int32_t prop = n;
        int32_t next = current + 4 + n;
        if(next < 0 || next >= CODE_MAX_SIZE){
          n = (int32_t)(code_size - current - 4);
        }
        n *= OP_ALIGN / 4;
        to_bytes(bytes, n, 4);
        op[0x14 + offset] = bytes[0];
        op[0x15 + offset] = bytes[1];
        op[0x16 + offset] = bytes[2];
        op[0x17 + offset] = bytes[3];
        uint64_t abs = (uint64_t)mem + INTRO_SIZE + (((current + 4 + prop) * OP_ALIGN) >> 2);
        to_bytes(abs_mem, abs, 8);
        op[0x06] = abs_mem[0]; op[0x07] = abs_mem[1];
        op[0x08] = abs_mem[2]; op[0x09] = abs_mem[3];
        op[0x0a] = abs_mem[4]; op[0x0b] = abs_mem[5];
        op[0x0c] = abs_mem[6]; op[0x0d] = abs_mem[7];
        mem_write(INTRO_SIZE + ((current * OP_ALIGN) >> 2), op, OP_ALIGN);

        (*jit)((uint64_t)registers, (uint64_t)counters, (uint64_t)flags, (uint64_t)code, (uint64_t)(&pqp_rip), (uint64_t)(&abs_addr));
        fprintf(out, "0x%.8X->JG_0x%.8X\n", current, current + 4 + prop);
        if(flags[0]){
          current += prop;
        }
        current += 4;
      }
      break;
    case 0x7:
      op = instruction_7;
      offset = OP_ALIGN - i_size[0x7];
      signal = code[current+3] >> 7 ? 0xff : 0x00;
      {
        uint8_t bytes[4] = {code[current+2], code[current+3], signal, signal};
        uint8_t abs_mem[8];
        int32_t n = from_bytes(bytes, 4);
        int32_t prop = n;
        int32_t next = current + 4 + n;
        if(next < 0 || next >= CODE_MAX_SIZE){
          n = (int32_t)(code_size - current - 4);
        }
        n *= OP_ALIGN / 4;
        to_bytes(bytes, n, 4);
        op[0x15 + offset] = bytes[0];
        op[0x16 + offset] = bytes[1];
        op[0x17 + offset] = bytes[2];
        op[0x18 + offset] = bytes[3];
        uint64_t abs = (uint64_t)mem + INTRO_SIZE + (((current + 4 + prop) * OP_ALIGN) >> 2);
        to_bytes(abs_mem, abs, 8);
        op[0x06] = abs_mem[0]; op[0x07] = abs_mem[1];
        op[0x08] = abs_mem[2]; op[0x09] = abs_mem[3];
        op[0x0a] = abs_mem[4]; op[0x0b] = abs_mem[5];
        op[0x0c] = abs_mem[6]; op[0x0d] = abs_mem[7];
        mem_write(INTRO_SIZE + ((current * OP_ALIGN) >> 2), op, OP_ALIGN);

        (*jit)((uint64_t)registers, (uint64_t)counters, (uint64_t)flags, (uint64_t)code, (uint64_t)(&pqp_rip), (uint64_t)(&abs_addr));
        fprintf(out, "0x%.8X->JL_0x%.8X\n", current, current + 4 + prop);
        if(flags[1]){
          current += prop;
        }
        current += 4;
      }
      break;
    case 0x8:
      op = instruction_8;
      offset = OP_ALIGN - i_size[0x8];
      signal = code[current+3] >> 7 ? 0xff : 0x00;
      {
        uint8_t bytes[4] = {code[current+2], code[current+3], signal, signal};
        uint8_t abs_mem[8];
        int32_t n = from_bytes(bytes, 4);
        int32_t prop = n;
        int32_t next = current + 4 + n;
        if(next < 0 || next >= CODE_MAX_SIZE){
          n = (int32_t)(code_size - current - 4);
        }
        n *= OP_ALIGN / 4;
        to_bytes(bytes, n, 4);
        op[0x15 + offset] = bytes[0];
        op[0x16 + offset] = bytes[1];
        op[0x17 + offset] = bytes[2];
        op[0x18 + offset] = bytes[3];
        uint64_t abs = (uint64_t)mem + INTRO_SIZE + (((current + 4 + prop) * OP_ALIGN) >> 2);
        to_bytes(abs_mem, abs, 8);
        op[0x06] = abs_mem[0]; op[0x07] = abs_mem[1];
        op[0x08] = abs_mem[2]; op[0x09] = abs_mem[3];
        op[0x0a] = abs_mem[4]; op[0x0b] = abs_mem[5];
        op[0x0c] = abs_mem[6]; op[0x0d] = abs_mem[7];
        mem_write(INTRO_SIZE + ((current * OP_ALIGN) >> 2), op, OP_ALIGN);

        (*jit)((uint64_t)registers, (uint64_t)counters, (uint64_t)flags, (uint64_t)code, (uint64_t)(&pqp_rip), (uint64_t)(&abs_addr));
        fprintf(out, "0x%.8X->JE_0x%.8X\n", current, current + 4 + prop);
        if(flags[2]){
          current += prop;
        }
        current += 4;
      }
      break;
    case 0x9:
      op = instruction_9;
      offset = OP_ALIGN - i_size[0x9];
      reg1_id = code[current+1] >> 4;
      reg2_id = code[current+1] & 0x0f;
      op[0x10 + offset] = reg2_id;
      op[0x15 + offset] = reg1_id;
      mem_write(INTRO_SIZE + ((current * OP_ALIGN) >> 2), op, OP_ALIGN);
      fprintf(out, "0x%.8X->ADD_R%d+=R%d=0x%.8X+0x%.8X=0x%.8X\n", current, reg1_id, reg2_id, registers[reg1_id], registers[reg2_id], registers[reg1_id] + registers[reg2_id]);
      (*jit)((uint64_t)registers, (uint64_t)counters, (uint64_t)flags, (uint64_t)code, (uint64_t)(&pqp_rip), (uint64_t)(&abs_addr));
      current += 4;
      break;
    case 0xa:
      op = instruction_a;
      offset = OP_ALIGN - i_size[0xa];
      reg1_id = code[current+1] >> 4;
      reg2_id = code[current+1] & 0x0f;
      op[0x10 + offset] = reg2_id;
      op[0x15 + offset] = reg1_id;
      mem_write(INTRO_SIZE + ((current * OP_ALIGN) >> 2), op, OP_ALIGN);
      fprintf(out, "0x%.8X->SUB_R%d-=R%d=0x%.8X-0x%.8X=0x%.8X\n", current, reg1_id, reg2_id, registers[reg1_id], registers[reg2_id], registers[reg1_id] - registers[reg2_id]);
      (*jit)((uint64_t)registers, (uint64_t)counters, (uint64_t)flags, (uint64_t)code, (uint64_t)(&pqp_rip), (uint64_t)(&abs_addr));
      current += 4;
      break;
    case 0xb:
      op = instruction_b;
      offset = OP_ALIGN - i_size[0xb];
      reg1_id = code[current+1] >> 4;
      reg2_id = code[current+1] & 0x0f;
      op[0x10 + offset] = reg2_id;
      op[0x15 + offset] = reg1_id;
      mem_write(INTRO_SIZE + ((current * OP_ALIGN) >> 2), op, OP_ALIGN);
      fprintf(out, "0x%.8X->AND_R%d&=R%d=0x%.8X&0x%.8X=0x%.8X\n", current, reg1_id, reg2_id, registers[reg1_id], registers[reg2_id], registers[reg1_id] & registers[reg2_id]);
      (*jit)((uint64_t)registers, (uint64_t)counters, (uint64_t)flags, (uint64_t)code, (uint64_t)(&pqp_rip), (uint64_t)(&abs_addr));
      current += 4;
      break;
    case 0xc:
      op = instruction_c;
      offset = OP_ALIGN - i_size[0xc];
      reg1_id = code[current+1] >> 4;
      reg2_id = code[current+1] & 0x0f;
      op[0x10 + offset] = reg2_id;
      op[0x15 + offset] = reg1_id;
      mem_write(INTRO_SIZE + ((current * OP_ALIGN) >> 2), op, OP_ALIGN);
      fprintf(out, "0x%.8X->OR_R%d|=R%d=0x%.8X|0x%.8X=0x%.8X\n", current, reg1_id, reg2_id, registers[reg1_id], registers[reg2_id], registers[reg1_id] | registers[reg2_id]);
      (*jit)((uint64_t)registers, (uint64_t)counters, (uint64_t)flags, (uint64_t)code, (uint64_t)(&pqp_rip), (uint64_t)(&abs_addr));
      current += 4;
      break;
    case 0xd:
      op = instruction_d;
      offset = OP_ALIGN - i_size[0xd];
      reg1_id = code[current+1] >> 4;
      reg2_id = code[current+1] & 0x0f;
      op[0x10 + offset] = reg2_id;
      op[0x15 + offset] = reg1_id;
      mem_write(INTRO_SIZE + ((current * OP_ALIGN) >> 2), op, OP_ALIGN);
      fprintf(out, "0x%.8X->XOR_R%d^=R%d=0x%.8X^0x%.8X=0x%.8X\n", current, reg1_id, reg2_id, registers[reg1_id], registers[reg2_id], registers[reg1_id] ^ registers[reg2_id]);
      (*jit)((uint64_t)registers, (uint64_t)counters, (uint64_t)flags, (uint64_t)code, (uint64_t)(&pqp_rip), (uint64_t)(&abs_addr));
      current += 4;
      break;
    case 0xe:
      op = instruction_e;
      offset = OP_ALIGN - i_size[0xe];
      reg_id = code[current+1] >> 4;
      op[0x10 + offset] = reg_id;
      op[0x1d + offset] = code[current+3];
      mem_write(INTRO_SIZE + ((current * OP_ALIGN) >> 2), op, OP_ALIGN);
      {
        uint8_t imm4 = code[current+3] > 31 ? 31 : code[current+3];
        fprintf(out, "0x%.8X->SAL_R%d<<=%d=0x%.8X<<%d=", current, reg_id, imm4, registers[reg_id], imm4); 
      }
      (*jit)((uint64_t)registers, (uint64_t)counters, (uint64_t)flags, (uint64_t)code, (uint64_t)(&pqp_rip), (uint64_t)(&abs_addr));
      fprintf(out, "0x%.8X\n", registers[reg_id]);
      current += 4;
      break;
    case 0xf:
      op = instruction_f;
      offset = OP_ALIGN - i_size[0xf];
      reg_id = code[current+1] >> 4;
      op[0x10 + offset] = reg_id;
      op[0x14 + offset] = code[current+3];
      mem_write(INTRO_SIZE + ((current * OP_ALIGN) >> 2), op, OP_ALIGN);
      {
        uint8_t imm4 = code[current+3] > 31 ? 31 : code[current+3];
        fprintf(out, "0x%.8X->SAR_R%d>>=%d=0x%.8X>>%d=", current, reg_id, imm4, registers[reg_id], imm4); 
      }
      (*jit)((uint64_t)registers, (uint64_t)counters, (uint64_t)flags, (uint64_t)code, (uint64_t)(&pqp_rip), (uint64_t)(&abs_addr));
      fprintf(out, "0x%.8X\n", registers[reg_id]);
      current += 4;
      break;
    default:
      current += 4;
  }
}

uint8_t* to_bytes(uint8_t* bytes, int64_t num, uint8_t size){
  if(!bytes){
    bytes = malloc(size);
  }
  for(uint8_t i = 0; i < size; i++){
    bytes[i] = num & 0xff;
    num >>= 8;
  }
  return bytes;
}

int64_t from_bytes(uint8_t* bytes, uint8_t size){
  int64_t n = 0;
  for(uint8_t i = 0; i < size; i++){
    n += bytes[i] << (i << 3);
  }
  return n;
}

void mem_write(uint32_t index, uint8_t* bytes, uint8_t size){
  uint8_t* mem_bytes = (uint8_t*)mem;
  for(uint32_t i = 0; i < size; i++){
    mem_bytes[index + i] = bytes[i];
  }
}

void process_init(){
  page_size = sysconf(_SC_PAGE_SIZE);
  code_size = 0;
  current = 0;
  code = malloc(CODE_MAX_SIZE);
  registers = calloc(16, 4);
  counters = calloc(16, 4);
  flags = calloc(3, 1);
  mem = mmap(0, page_size, PROT_EXEC | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  pqp_rip = (uint64_t)mem + INTRO_SIZE;
  
  uint8_t intro[INTRO_SIZE] = {0x55, 0x48, 0x89, 0xE5, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x89, 0x7D, 0xF8, 0x48, 0x89, 0x75, 0xF0, 0x48, 0x89, 0x55, 0xE8, 0x48, 0x89, 0x4D, 0xE0, 0x4C, 0x89, 0x45, 0xD8, 0x4C, 0x89, 0x4D, 0xD0, 0x48, 0x8B, 0x45, 0xD8, 0xFF, 0x20, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90};

  mem_write(0, intro, INTRO_SIZE);
}

void process_finish(){
  free(registers);
  free(counters);
  free(code);
  free(flags);
  munmap(mem, page_size);
}